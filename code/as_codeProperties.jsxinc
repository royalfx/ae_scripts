/**
 * as_codeProperties.jsxinc
 * version: 1.0.2
 * author: Alexander Semeniuk
 * date: Jul 16 2019
 * 
 * @param comp 
 * @param prop 
 * @param addComments 
 * @param linesCollector 
 * @param errorsCollector 
 */
function as_codeProperties(comp, prop, addComments, linesCollector, errorsCollector) {
    
    // VARS
    var doAddProperty = false;
    var propPath;
    // CHECK TYPE
    if (prop.propertyType == PropertyType.PROPERTY) {
        if ((prop.propertyValueType != PropertyValueType.NO_VALUE) && (prop.propertyValueType != PropertyValueType.CUSTOM_VALUE)) {
            // ! SKIP NOT SUPPORTED PROPS
            if (prop.propertyValueType == PropertyValueType.SHAPE) {
                errorsCollector.push("Warning: Shape values not supported yet! (prop: \"" + prop.name + "\")");
                return linesCollector;
            }
            if (prop.propertyValueType == PropertyValueType.MARKER) {
                // new MarkerValue(comment, chapter, url, frameTarget, cuePointName, params)
                errorsCollector.push("Warning: MarkerValue not supported yet! (prop: \"" + prop.name + "\")");
                return linesCollector;
            }
            // ! SKIP SOME PROPS
            if ((prop.matchName == "ADBE Position_0") || (prop.matchName == "ADBE Position_1") || (prop.matchName == "ADBE Position_2")) {
                return linesCollector;
            }
            // IF KEYFRAMES
            if (prop.numKeys > 0) {
                errorsCollector.push("Warning: Keyframes not supported yet! (prop: \"" + prop.name + "\")");
            }
            // ADD OR SET
            if (prop.parentProperty.matchName == "ADBE Text Animator Properties") {
                // TRY SET VALUE
                try {
                    if (prop.numKeys == 0) {
                        prop.setValue(prop.valueAtTime(comp.time, true));
                    }
                    else {
                        prop.setValueAtTime(prop.keyTime(1), prop.keyValue(1));
                    }
                    doAddProperty = true;
                }
                catch (err) {
                    // IS HIDDEN
                    // errorsCollector.push("Error: " + err.message);
                    return linesCollector;
                }
            }
            else if (prop.parentProperty && (prop.parentProperty.propertyType == PropertyType.INDEXED_GROUP)) {
                doAddProperty = true;
            }
            else if (!prop.isModified) {
                // ! SKIP IF NOT MODIFIED
                return linesCollector;
            }
            // + PROP
            if (addComments) {
                linesCollector.push("// PROP: " + prop.name);
            }
            // ADD PROP
            if (doAddProperty) {
                propPath = "prop" + prop.name.replace(new RegExp("[^a-zA-Z0-9]", "g"), "").substr(0, 20);
                linesCollector.push("var " + propPath + " = " + as_codeGetPropPath(prop.parentProperty) + ".addProperty(\"" + prop.matchName + "\");");
            }
            else {
                propPath = as_codeGetPropPath(prop);
            }
            // + PROP
            if (prop.propertyValueType == PropertyValueType.TEXT_DOCUMENT) {
                // TEXT_DOCUMENT
                var textDoc = prop.valueAtTime(comp.time, true);
                linesCollector.push("var textDoc = " + propPath + ".value;");
                linesCollector.push("textDoc.resetCharStyle();");
                linesCollector.push("textDoc.fontSize = " + textDoc.fontSize + ";");
                linesCollector.push("textDoc.font = \"" + textDoc.font + "\";");
                linesCollector.push("textDoc.applyFill = " + textDoc.applyFill + ";");
                linesCollector.push("textDoc.fillColor = " + as_toString(textDoc.fillColor) + ";");
                if (textDoc.applyStroke) {
                    linesCollector.push("textDoc.applyStroke = " + textDoc.applyStroke + ";");
                    linesCollector.push("textDoc.strokeColor = " + as_toString(textDoc.strokeColor) + ";");
                    linesCollector.push("textDoc.strokeWidth = " + textDoc.strokeWidth + ";");
                    linesCollector.push("textDoc.strokeOverFill = " + textDoc.strokeOverFill + ";");
                }
                linesCollector.push("textDoc.text = \"" + textDoc.text + "\";");
                linesCollector.push("textDoc.justification = ParagraphJustification." + as_getConstName(textDoc.justification, ParagraphJustification) + ";");
                linesCollector.push("textDoc.tracking = " + textDoc.tracking + ";");
                linesCollector.push(propPath + ".setValue(textDoc);");
            }
            else if (prop.propertyValueType == PropertyValueType.OneD) {
                // ONE_D
                // linesCollector.push("try {");
                linesCollector.push("\t" + propPath + ".setValue(" + prop.valueAtTime(comp.time, true).toString() + ");");
                // linesCollector.push("} catch(err) {\n\terrorsCollector.push(\"Can't\ set value to property \\\"" + prop.name + "\\\"!\");\n}");
                // linesCollector.push(propPath + ".setValue(" + prop.valueAtTime(comp.time, true).toString() + ");");
            }
            else {
                // ARRAYS
                // linesCollector.push("try {");
                linesCollector.push("\t" + propPath + ".setValue([" + prop.valueAtTime(comp.time, true).toString() + "]);");
                // linesCollector.push("} catch(err) {\n\terrorsCollector.push(\"Can't\ set value to property \\\"" + prop.name + "\\\"!\");\n}");
                // linesCollector.push(propPath + ".setValue([" + prop.valueAtTime(comp.time, true).toString() + "]);");
            }
            // validTypes.push(PropertyValueType.ThreeD);
            // validTypes.push(PropertyValueType.ThreeD_SPATIAL);
            // validTypes.push(PropertyValueType.TwoD);
            // validTypes.push(PropertyValueType.TwoD_SPATIAL);
            // validTypes.push(PropertyValueType.OneD);
            // validTypes.push(PropertyValueType.COLOR);
            // validTypes.push(validTypes.push(PropertyValueType.NO_VALUE);
            // validTypes.push(PropertyValueType.CUSTOM_VALUE);
            // validTypes.push(PropertyValueType.MARKER);
            // validTypes.push(PropertyValueType.LAYER_INDEX); // Can't set expression!
            // validTypes.push(PropertyValueType.MASK_INDEX);
            // validTypes.push(PropertyValueType.SHAPE);
            // validTypes.push(PropertyValueType.TEXT_DOCUMENT);
            // + EXPRESSION
            if (prop.expression != "") {
                var expr = prop.expression;
                expr = expr.replace(new RegExp("\r", "g"), "\n");
                expr = expr.replace(new RegExp("\n\n", "g"), "\n");
                // linesCollector.push("try {");
                linesCollector.push("\t" + propPath + ".expression = \"" + as_toCodeString(expr) + "\";");
                if (prop.expressionEnabled == false) {
                    linesCollector.push("\t" + propPath + ".expressionEnabled = false;");
                    // linesCollector.push(propPath + ".expressionEnabled = false;");
                }
                // linesCollector.push("} catch(err) {\n\terrorsCollector.push(\"Can't\ set expression to property \\\"" + prop.name + "\\\"!\");\n}");
                // linesCollector.push(propPath + ".expression = \"" + as_toCodeString(expr) + "\";");
            }
        }
    }
    else {
        // + GROUP
        if (prop.parentProperty && (prop.parentProperty.propertyType == PropertyType.INDEXED_GROUP)) {
            if (as_isEffect(prop)) {
                // + EFFECT STEP
                linesCollector.push("\t");
                // + ADD EFFECT
                if (addComments) {
                    linesCollector.push("// EFFECT: " + prop.name);
                }
                propPath = "effect" + prop.name.replace(new RegExp("[^a-zA-Z0-9]", "g"), "").substr(0, 20);
                linesCollector.push("var " + propPath + " = " + as_codeGetPropPath(prop.parentProperty) + ".addProperty(\"" + prop.matchName + "\");");
                linesCollector.push(propPath + ".name = \"" + prop.name + "\";");
                if (!prop.enabled) {
                    linesCollector.push(propPath + ".enabled = " + prop.enabled + ";");
                }
            }
            else {
                // + PROP
                if (addComments) {
                    linesCollector.push("// GROUP: " + prop.name);
                }
                propPath = "group" + prop.name.replace(new RegExp("[^a-zA-Z0-9]", "g"), "").substr(0, 20);
                linesCollector.push("var " + propPath + " = " + as_codeGetPropPath(prop.parentProperty) + ".addProperty(\"" + prop.matchName + "\");");
                linesCollector.push(propPath + ".name = \"" + prop.name + "\";");
            }
        }
        // + LOOP CHILDREN PROPS
        for (var p = 1; p <= prop.numProperties; p++) {
            as_codeProperties(comp, prop.property(p), addComments, linesCollector, errorsCollector);
        }
    }
    // RETURN
    return linesCollector;
}
