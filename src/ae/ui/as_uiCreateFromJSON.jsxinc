// Copyright (c) 2019 Oleksandr Semeniuk
// This code is licensed under MIT license
// See also http://www.opensource.org/licenses/mit-license.php

// version: 1.0.1
// date: Aug 13 2019

/**
 * 
 * @param {Window} windowObj 
 * @param {object} dataUI JSON data created by as_uiCSVToJSON()
 * @param {object} dataImages JSON data with images binary (Optional)
 * @param {Folder} dirImages Folder to save images (Optional)
 * @param {boolean} rewriteFiles If false existing images will be used
 */
function as_uiCreateFromJSON(windowObj, dataUI, dataImages, dirImages, rewriteFiles) {
	try {

		// VARS
		var uiElement, dataElement, elementContainer, fileName;

		// LOOP JSON
		for (var elementName in dataUI) {
			if (dataUI.hasOwnProperty(elementName)) {
				dataElement = dataUI[elementName];

				// GET CONTAINER
				// If parent container is Window/Panel leave empty field in spreadsheet.
				if (dataElement.container === undefined) {
					elementContainer = windowObj;
				} else {
					elementContainer = as_uiFindElement(windowObj, dataElement.container);
				}

				// CHECK CONTAINER
				if (!elementContainer) {
					alert(arguments.callee.name + " --> " + "Container " + dataElement.container + " not found!" + "\nElement: " + elementName);
					continue;
				}

				// CREATE UI ELEMENT
				switch (dataElement.type) {
					case "image":
						uiElement = elementContainer.add("image", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					case "button":
						uiElement = elementContainer.add("button", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					case "iconbutton":
						uiElement = elementContainer.add("iconbutton", dataElement.bounds, undefined, {
							name: (elementName),
							style: (dataElement.style || "toolbutton")
						});
						break;
					case "custombutton":
						uiElement = elementContainer.add("custombutton", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					case "statictext":
						uiElement = elementContainer.add("statictext", dataElement.bounds, undefined, {
							name: (elementName),
							multiline: (dataElement.multiline || false),
							justify: (dataElement.justify || "left")
						});
						if (dataElement.justify !== undefined) {
							uiElement.justify = dataElement.justify;
						}
						break;
					case "edittext":
						uiElement = elementContainer.add("edittext", dataElement.bounds, undefined, {
							name: (elementName),
							multiline: (dataElement.multiline || false),
							readonly: (dataElement.readonly || false),
							justify: (dataElement.justify || "left")
						});
						if (dataElement.justify !== undefined) {
							uiElement.justify = dataElement.justify;
						}
						break;
					case "group":
						uiElement = elementContainer.add("group", dataElement.bounds, {
							name: (elementName)
						});
						break;
					case "dropdownlist":
						uiElement = elementContainer.add("dropdownlist", dataElement.bounds, dataElement.items, { name: (elementName) });
						uiElement.selection = 0;
						break;
					case "scrollbar":
						uiElement = elementContainer.add("scrollbar", dataElement.bounds, undefined, undefined, undefined, {
							name: (elementName)
						});
						break;
					case "progressbar":
						//add (progressbar [, bounds, value, minvalue, maxvalue,{creation_properties}]);
						uiElement = elementContainer.add("progressbar", dataElement.bounds, undefined, undefined, undefined, {
							name: (elementName)
						});
						break;
					case "listbox":
						uiElement = elementContainer.add("listbox", dataElement.bounds, undefined, {
							name: (elementName),
							numberOfColumns: (dataElement.numberOfColumns),
							showHeaders: (dataElement.showHeaders),
							columnTitles: (dataElement.columnTitles),
							columnWidths: (dataElement.columnWidths)
						});
						break;
					case "checkbox":
						uiElement = elementContainer.add("checkbox", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					case "tabbedpanel":
						uiElement = elementContainer.add("tabbedpanel", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					case "panel":
						uiElement = elementContainer.add("panel", dataElement.bounds, undefined, { name: (elementName), borderStyle: "etched" });
						break;
						// borderStyle: 
						// black, etched, gray, raised, sunken. Default is etched
					case "tab":
						uiElement = elementContainer.add("tab", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					case "radiobutton":
						uiElement = elementContainer.add("radiobutton", dataElement.bounds, undefined, {
							name: (elementName)
						});
						break;
					default:
						alert(arguments.callee.name + " --> " + "unaccounted type:" + dataElement.type + ", elementName:" + elementName);
						break;
				}

				// PREPARE IMAGES
				if(dataImages && dirImages) {
					var imagesMap = {};
					if (dataElement.icon !== undefined) {
						fileName = dataElement.icon;
						if (imagesMap[fileName] === undefined) {
							imagesMap[fileName] = as_uiImageFromBinary(dataImages[dataElement.icon], fileName, dirImages, rewriteFiles);
						}
					}
				}
				
				// SKIP CREATION PROPERTIES
				var skipProps = ["name", "type", "bounds", "style", "multiline", "justify", "readonly", "items", "columnWidths", "columnTitles", "showHeaders", "numberOfColumns", "borderStyle"];
				
				// LOOP PROPERTIES
				for (var propName in dataElement) {
					if(dataElement.hasOwnProperty(propName)) {

						// CHECK SKIP
						if (as_arrayCheckValue(propName, skipProps) < 0) {
							var propValue = dataElement[propName];

							// IF IMAGE
							if(propName == "icon") {
								if(imagesMap && imagesMap[propValue]) {
									uiElement[propName] = imagesMap[propValue];
								}

							// IF ANY PROPERTY
							} else {
								uiElement[propName] = propValue;
							}
						}
					}
				}
			}
		}
	} catch (err) {
		alert(propValue);
		alert(arguments.callee.name + " --> " + err.name + " at line " + err.line + " : " + err.message);
	}
}
